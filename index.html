<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <title>Balloon Blast Party üéà</title>
  
  <!-- App Icon Links -->
  <link rel="icon" href="https://placehold.co/32x32/87CEEB/FFFFFF/png?text=üéà" type="image/png">
  <link rel="apple-touch-icon" href="https://placehold.co/180x180/87CEEB/FFFFFF/png?text=üéà">
  <link rel="icon" sizes="192x192" href="https://placehold.co/192x192/87CEEB/FFFFFF/png?text=üéà">
  <link rel="icon" sizes="512x512" href="https://placehold.co/512x512/87CEEB/FFFFFF/png?text=üéà">

  <style>
    :root{
      --ui-bg:#87CEEB;
      --btn-shadow:0 6px 16px rgba(0,0,0,.25);
      --card-shadow:0 10px 24px rgba(0,0,0,.35);
      --radius:18px;
      --font:"Comic Sans MS", "Baloo 2", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    html,body{height:100%;margin:0;background:var(--ui-bg);font-family:var(--font);touch-action:manipulation; overflow: hidden;}

    /* Layout */
    #gameWrap{position:relative; width:100vw; height:100vh; overflow:hidden;}
    #gameCanvas{position:absolute; inset:0; width:100vw; height:100vh; display:block; background:linear-gradient(#8ed2ff,#bfe9ff); transition: background .5s ease;}

    /* NEW FEATURE: Keyframes and styles for animated backgrounds */
    @keyframes move-clouds { 0% { background-position: 0 0; } 100% { background-position: 1000px 0; } }
    @keyframes move-stars { 0% { background-position: 0 0; } 100% { background-position: 0 600px; } }
    @keyframes sun-glow { 0%, 100% { box-shadow: 0 0 60px 20px #FFF380; } 50% { box-shadow: 0 0 80px 30px #FFD700; } }
    #sun { position: absolute; top: 15%; right: 15%; width: 100px; height: 100px; background: #FFD700; border-radius: 50%; animation: sun-glow 8s infinite ease-in-out; display: none; z-index: -1; }
    @keyframes move-aurora { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }

    /* HUD */
    #hud{ position: fixed; top: 40px; left: 50%; transform: translateX(-50%); display:flex; flex-direction: column; align-items:center; padding:.6rem 1rem; border-radius:999px; background:rgba(0,0,0,.25); color:#fff; font-weight:700; line-height:1.2; backdrop-filter: blur(8px); box-shadow:var(--btn-shadow); z-index: 5; gap: 5px; }
    .hud-row { display: flex; justify-content: center; align-items: center; gap: 15px; font-size: 13px; }
    #hud span{white-space:nowrap}
    @media(min-width: 480px) { #hud { flex-direction: row; gap: 20px; } .hud-row { gap: 20px; font-size: 14px; } }
    #shieldTimer { color: #39ff14; font-weight: bold; text-shadow: 0 0 5px black; }

    /* Controls (Original styles retained) */
    #leftVerticalControls { position: fixed; top: 120px; left: 15px; padding-left: env(safe-area-inset-left, 0px); display: flex; flex-direction: column; gap: 10px; z-index: 5; }
    .util-btn { width: 44px; height: 44px; border:none; border-radius:50%; color:#fff; font-size: 22px; display:grid; place-items:center; box-shadow:var(--btn-shadow); cursor:pointer; outline:none; transition: transform .1s, opacity .1s; }
    #settingsBtn { background: #795548; } #helpBtnTop { background: #9c27b0; }
    .util-btn:active { transform: translateY(1px); opacity: .9; }
    #controls-container { position: fixed; bottom: 65px; left: 50%; transform: translateX(-50%); padding: 8px; border-radius: 999px; background: rgba(0,0,0,.25); backdrop-filter: blur(8px); box-shadow: var(--btn-shadow); z-index: 5; }
    #controls{ display:flex; flex-wrap: nowrap; gap: 10px; align-items:center; }
    .btn{ width: 44px; height: 44px; max-width: 44px; max-height: 44px; min-width: 36px; min-height: 36px; border:none; border-radius:50%; color:#fff; font-size: 18px; display:grid; place-items:center; box-shadow:var(--btn-shadow); cursor:pointer; outline:none; transition: transform .1s, opacity .1s; }
    .start{background:#4caf50} .stop{background:#f44336} .switch{background:#2196f3} .again{background:#607d8b; display:none} .leaders{background:#ff9800} .mute{background:#ffb300} .palette{background:#00bcd4}
    .btn:active{transform:translateY(1px); opacity:.9}

    /* Popups (Original styles retained) */
    .popup{ position:fixed; inset:0; display:none; place-items:center; z-index:10; background:rgba(0,0,0,.35); }
    .card{ width:86vw; max-width:400px; background:#fff; border-radius:22px; box-shadow:var(--card-shadow); padding:16px; border:4px solid #4a4a4a; }
    .card h2{ margin:4px 0 10px; font-size:22px; display:flex; align-items:center; gap:8px; justify-content: center;}
    .close, .share { margin:12px 6px 2px; display:inline-block; padding:10px 18px; border:none; border-radius:999px; color:#fff; font-size:16px; box-shadow:var(--btn-shadow); cursor:pointer; }
    .close { background:#ff595e; } .share { background:#1e90ff; }
    #shareBtn { display: none; } .card .button-group { text-align: center; }
    .card table{ width:100%; border-collapse:collapse; font-weight:700; font-size: 14px; }
    .card th, .card td{ padding:10px 6px; border-bottom:1px solid #e6e6e6; text-align:left; }
    .card tbody tr:nth-child(odd){ background-color: #f8f8f8; }
    .card tbody tr:first-child { font-weight: 900; background-color: #fff3cd; }
    .card tbody tr:first-child td:first-child::before { content: 'üëë '; }

    /* Settings & Messages (Original styles retained) */
    .settings-grid { display: grid; grid-template-columns: 1fr auto; gap: 12px 10px; align-items: center; margin-top: 16px; }
    .settings-grid label { font-weight: 700; }
    .settings-grid select, .settings-grid input { padding: 6px; border-radius: 8px; border: 1px solid #ccc; font-family: var(--font); }
    #levelUpMsg { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 15vw; font-weight: bold; color: white; text-shadow: 0 0 15px rgba(0,0,0,0.8); opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.5s ease-out, transform 0.5s ease-out; }
    #levelUpMsg.show { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }

    /* Compat Popup (Original styles retained) */
    #compatPopup { position: fixed; inset: 0; display: none; place-items: center; z-index: 9999; background: rgba(0,0,0,0.45); }
    #compatPopup .compatCard { width: 86vw; max-width: 360px; background: #fff; border-radius: 16px; padding: 16px; box-shadow: var(--card-shadow); text-align: center; }
    #compatPopup input[type="text"]{ width: 82%; padding: 8px; margin-top: 8px; border-radius: 8px; border: 1px solid #ddd; font-size: 16px; }
    #compatPopup .compatBtns { margin-top: 12px; display:flex; gap:12px; justify-content:center; }
    #compatPopup .compatBtns button { padding:8px 14px; border:none; border-radius:999px; font-weight:700; cursor:pointer; }
    #compatOk { background:#4caf50; color:#fff; } #compatCancel { background:#f44336; color:#fff; }
  </style>
</head>
<body>
  <div id="gameWrap">
    <canvas id="gameCanvas"></canvas>
    <!-- NEW FEATURE: Sun element for sunset theme -->
    <div id="sun"></div>
    
    <div id="levelUpMsg">Level Up!</div>

    <div id="hud">
        <div class="hud-row"> <span id="scoreTxt">üéØ Score: 0</span> <span id="bestTxt">üèÜ Best: 0</span> <span id="missTxt">‚ùå Missed: 0/5</span> </div>
        <div class="hud-row"> <span id="whoTxt">üë§ Player: ‚Äî</span> <span id="shieldTimer" style="display:none;"></span> </div>
    </div>

    <div id="leftVerticalControls">
        <button id="settingsBtn" class="util-btn" data-tip="Settings">‚öôÔ∏è</button>
        <button id="helpBtnTop"  class="util-btn" data-tip="Help">‚ùì</button>
    </div>

    <div id="controls-container">
        <div id="controls">
          <button id="startBtn"   class="btn start"   data-tip="Start">‚ñ∂</button>
          <button id="stopBtn"    class="btn stop"    data-tip="Stop" style="display:none;">‚èπ</button>
          <button id="againBtn"   class="btn again"   data-tip="Play Again">üîÅ</button>
          <button id="switchBtn"  class="btn switch"  data-tip="Switch Player">üîÑ</button>
          <button id="leadersBtn" class="btn leaders" data-tip="Leaders">üèÜ</button>
          <button id="paletteBtn" class="btn palette" data-tip="Change Theme">üé®</button>
          <button id="muteBtn"    class="btn mute"    data-tip="Mute / Unmute">üîä</button>
        </div>
    </div>

    <!-- Popups HTML structure remains identical to original file -->
    <div id="gameOverPopup" class="popup">
        <div class="card">
            <h2 id="gameOverTitle">Game Over!</h2>
            <p id="gameOverMsg" style="text-align:center; font-weight:bold;"></p>
            <div class="button-group"> <button id="shareBtn" class="share">Share Score</button> <button id="closeGameOver" class="close">Close</button> </div>
        </div>
    </div>
    <div id="leaderPopup" class="popup">
      <div class="card">
        <h2>üèÜ Leaderboard üèÜ</h2>
        <table> <thead><tr><th>Name</th><th>Best Score</th><th>Level</th><th>Date</th></tr></thead> <tbody id="leaderBody"></tbody> </table>
        <button id="closeLeaders" class="close">Close</button>
      </div>
    </div>
    <div id="settingsPopup" class="popup">
        <div class="card">
            <h2>‚öôÔ∏è Game Settings ‚öôÔ∏è</h2>
            <div class="settings-grid">
                <label for="speedSelect">üéØ Balloon Speed:</label> <select id="speedSelect"> <option value="very-slow">Very Slow</option> <option value="slow">Slow</option> <option value="normal">Normal</option> <option value="fast">Fast</option> <option value="very-fast">Very Fast</option> </select>
                <label for="difficultySelect">üéÆ Difficulty:</label> <select id="difficultySelect"> <option value="very-easy">Very Easy</option> <option value="easy">Easy</option> <option value="medium">Medium</option> <option value="hard">Hard</option> <option value="insane">Insane</option> </select>
                <label for="missesRange">üéà Misses Allowed:</label> <span><input type="range" id="missesRange" min="3" max="10" value="5"><span id="missesValue">5</span></span>
                <label for="hapticsToggle">üì≥ Vibration:</label> <input type="checkbox" id="hapticsToggle" checked>
            </div>
            <button id="closeSettings" class="close" style="display:block; margin:20px auto;">Save & Close</button>
        </div>
    </div>
    <div id="compatPopup" aria-hidden="true">
      <div class="compatCard" role="dialog" aria-modal="true">
        <h3 id="compatTitle">Info</h3>
        <p id="compatMsg" style="margin:6px 0 0;"></p>
        <input type="text" id="compatInput" style="display:none" />
        <div class="compatBtns"> <button id="compatOk">OK</button> <button id="compatCancel" style="display:none">Cancel</button> </div>
      </div>
    </div>
</div>

<script>
/* ---------- Compatibility utilities (Original code) ---------- */
function showCompat(message, options){ return new Promise((resolve)=>{ const popup=document.getElementById('compatPopup'),titleEl=document.getElementById('compatTitle'),msgEl=document.getElementById('compatMsg'),inputEl=document.getElementById('compatInput'),ok=document.getElementById('compatOk'),cancel=document.getElementById('compatCancel'); titleEl.textContent=options?.title||(options?.type==='prompt'?'Input':'Info'); msgEl.textContent=message||''; inputEl.style.display=options?.type==='prompt'?'block':'none'; inputEl.value=options?.defaultValue||''; cancel.style.display=options?.type==='prompt'?'inline-block':'none'; popup.style.display='grid'; popup.setAttribute('aria-hidden','false'); function cleanup(){ popup.style.display='none'; popup.setAttribute('aria-hidden','true'); ok.removeEventListener('click',onOk); cancel.removeEventListener('click',onCancel); } function onOk(){ cleanup(); resolve(options?.type==='prompt'?inputEl.value:true); } function onCancel(){ cleanup(); resolve(null); } ok.addEventListener('click',onOk,{once:true}); cancel.addEventListener('click',onCancel,{once:true}); }); }
window.alert=function(msg){showCompat(String(msg),{type:'alert'});}; window.prompt=function(){console.warn('Sync prompt not supported.'); return null;}; function promptCompat(message,defaultValue){return showCompat(String(message),{type:'prompt',defaultValue:defaultValue});}
function bindTap(el,handler){ if(!el)return; let touchFired=!1; el.addEventListener('touchstart',function(e){touchFired=!0; e.preventDefault(); handler(e); setTimeout(()=>touchFired=!1,300)}); el.addEventListener('click',function(e){if(touchFired)return; handler(e);}); }
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d",{ alpha: true, desynchronized:true });
    function resizeCanvas(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const w = Math.floor(window.innerWidth); const h = Math.floor(window.innerHeight);
      canvas.style.width = w + "px"; canvas.style.height = h + "px";
      canvas.width = w * dpr; canvas.height = h * dpr;
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const faces = [ { eyes: 'normal', mouth: 'smile' }, { eyes: 'wink', mouth: 'smile' }, { eyes: 'surprised', mouth: 'open' }, { eyes: 'happy', mouth: 'big_smile' } ];
    let balloons = [], particles = [];
    let score = 0, bestScore = 0, playerName = "", currentLevel = 1;
    let gameTimer = null, spawnTimer = null;
    let isPlaying = false, missed = 0, MAX_MISSES = 5, isMuted = false;
    let isShieldActive = false, shieldTimeout = null, shieldInterval = null;
    let isSlowMo = false, slowMoTimeout = null;
    // NEW FEATURE: State variables for Boss Level
    let isBossLevel = false, bossBalloon = null;

    let settings = { speed: 'normal', difficulty: 'medium', maxMisses: 5, haptics: true };
    
    // NEW FEATURE: Expanded themes array with animated backgrounds
    const sunEl = document.getElementById("sun");
    const themes = [
        // 5 Plain Backgrounds (Original)
        'linear-gradient(#8ed2ff,#bfe9ff)',
        'linear-gradient(#90ee90,#c1ffc1)',
        'linear-gradient(#ffb6c1,#ffe4e1)',
        'linear-gradient(#dda0dd,#e6e6fa)',
        'linear-gradient(#ffcc80,#fff3e0)',
        // 5 Animated Backgrounds (New)
        { type: 'anim', style: `linear-gradient(to bottom, #000428, #004e92), radial-gradient(circle at 20% 20%, white 1px, transparent 2px), radial-gradient(circle at 80% 10%, white 1px, transparent 2px), radial-gradient(circle at 50% 70%, white 1px, transparent 2px), radial-gradient(circle at 90% 90%, white 1px, transparent 2px)`, animation: 'move-stars 20s linear infinite' },
        { type: 'anim', style: `linear-gradient(to bottom, #87CEEB, #f0f8ff), radial-gradient(circle at 10% 20%, white 40px, transparent 41px), radial-gradient(circle at 60% 30%, white 60px, transparent 61px), radial-gradient(circle at 85% 15%, white 30px, transparent 31px)`, animation: 'move-clouds 30s linear infinite' },
        { type: 'anim', style: 'linear-gradient(to top, #fca5a5, #fde047, #60a5fa)', sun: true },
        { type: 'anim', style: 'linear-gradient(270deg, #ff00ff, #00ffff, #ffff00, #ff00ff)', animation: 'move-aurora 10s ease infinite', backgroundSize: '400% 400%' },
    ];
    let currentTheme = 0;
    
    // All original DOM element variables are kept
    const levelUpMsgEl = document.getElementById("levelUpMsg"), shieldTimerEl = document.getElementById("shieldTimer"),
          scoreTxt = document.getElementById("scoreTxt"), bestTxt  = document.getElementById("bestTxt"),
          missTxt  = document.getElementById("missTxt"), whoTxt   = document.getElementById("whoTxt"),
          startBtn   = document.getElementById("startBtn"), stopBtn    = document.getElementById("stopBtn"),
          againBtn   = document.getElementById("againBtn"), switchBtn  = document.getElementById("switchBtn"),
          leadersBtn = document.getElementById("leadersBtn"), paletteBtn = document.getElementById("paletteBtn"),
          muteBtn    = document.getElementById("muteBtn"), settingsBtn= document.getElementById("settingsBtn"), 
          helpBtnTop = document.getElementById("helpBtnTop"), leaderPopup   = document.getElementById("leaderPopup"), 
          leaderBody    = document.getElementById("leaderBody"), closeLeaders  = document.getElementById("closeLeaders"),
          settingsPopup = document.getElementById("settingsPopup"), closeSettings = document.getElementById("closeSettings"),
          speedSelect = document.getElementById("speedSelect"), difficultySelect = document.getElementById("difficultySelect"),
          missesRange = document.getElementById("missesRange"), missesValue = document.getElementById("missesValue"),
          hapticsToggle = document.getElementById("hapticsToggle"), gameOverPopup = document.getElementById("gameOverPopup"),
          gameOverTitle = document.getElementById("gameOverTitle"), gameOverMsg = document.getElementById("gameOverMsg"),
          shareBtn = document.getElementById("shareBtn"), closeGameOver = document.getElementById("closeGameOver");

    // All original audio and game state functions are kept
    let audioCtx = null, bgNode = null, bgTimer = null;
    function initAudio() { if (!audioCtx) { const AudioContext = window.AudioContext || window.webkitAudioContext; try { audioCtx = new AudioContext(); } catch(e){ console.warn("AudioContext not available:", e); } } }
    document.body.addEventListener('pointerdown', initAudio, { once: true });
    function playSound(type) {
        if (isMuted || !audioCtx) return;
        const now = audioCtx.currentTime; const g = audioCtx.createGain(); g.connect(audioCtx.destination); g.gain.setValueAtTime(0.6, now);
        switch(type){
            case 'pop': { const o=audioCtx.createOscillator(); o.type="triangle"; o.frequency.setValueAtTime(180,now); o.frequency.exponentialRampToValueAtTime(60,now+0.08); g.gain.exponentialRampToValueAtTime(0.001,now+0.1); o.connect(g); o.start(now); o.stop(now+0.11); break; }
            case 'powerup': case 'bling': { g.gain.exponentialRampToValueAtTime(0.001,now+0.35); [660, 990, 1320].forEach((f, i) => { const o=audioCtx.createOscillator(); o.type="sine"; o.frequency.setValueAtTime(f,now+i*0.04); o.connect(g); o.start(now+i*0.04); o.stop(now+i*0.04+0.18); }); break; }
            case 'fail': { const o=audioCtx.createOscillator(); o.type="sawtooth"; o.frequency.setValueAtTime(400,now); o.frequency.exponentialRampToValueAtTime(120,now+0.35); g.gain.linearRampToValueAtTime(0.001,now+0.35); o.connect(g); o.start(now); o.stop(now+0.36); break; }
            case 'new_highscore': { g.gain.exponentialRampToValueAtTime(0.001,now+0.8); [523,659,783,1046].forEach((f, i)=>{ const o=audioCtx.createOscillator(); o.type="sine"; o.frequency.setValueAtTime(f,now+i*0.1); o.connect(g); o.start(now+i*0.1); o.stop(now+i*0.1+0.2); }); break; }
            // NEW FEATURE: Boss and bomb sounds
            case 'boss_hit': { const o=audioCtx.createOscillator();o.type="square";o.frequency.setValueAtTime(80,now);g.gain.exponentialRampToValueAtTime(0.001,now+0.2);o.connect(g);o.start(now);o.stop(now+0.2); break; }
            case 'explosion': { const noise=audioCtx.createBufferSource();const buffer=audioCtx.createBuffer(1,audioCtx.sampleRate*0.5,audioCtx.sampleRate);const data=buffer.getChannelData(0);for(let i=0;i<data.length;i++){data[i]=Math.random()*2-1;}noise.buffer=buffer;const filter=audioCtx.createBiquadFilter();filter.type="lowpass";filter.frequency.setValueAtTime(1000,now);filter.frequency.exponentialRampToValueAtTime(100,now+0.3);noise.connect(filter).connect(g);noise.start(now);noise.stop(now+0.3);g.gain.exponentialRampToValueAtTime(0.001,now+0.3); break; }
        }
    }
    function startBG(){ if (isMuted || !audioCtx) return; stopBG(); const tempo=120, beat=60/tempo, notes=[523,587,659,698,659,587,523,392]; bgNode = audioCtx.createGain(); bgNode.gain.value=0.2; bgNode.connect(audioCtx.destination); for(let i=0;i<64;i++){ const t = audioCtx.currentTime + i*beat*0.5, o = audioCtx.createOscillator(), g = audioCtx.createGain(); o.type="square"; o.frequency.value = notes[i%notes.length]; g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.15,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+beat*0.45); o.connect(g).connect(bgNode); o.start(t); o.stop(t+beat*0.5); } bgTimer = setTimeout(startBG, beat*1000*32); }
    function stopBG(){ if (bgTimer) clearTimeout(bgTimer); if(bgNode){ bgNode.disconnect(); bgNode=null; } }
    function saveSettings() { localStorage.setItem('balloon_settings', JSON.stringify(settings)); }
    function loadSettings() { const saved = localStorage.getItem('balloon_settings'); if (saved) { Object.assign(settings, JSON.parse(saved)); } MAX_MISSES = settings.maxMisses; speedSelect.value = settings.speed; difficultySelect.value = settings.difficulty; missesRange.value = settings.maxMisses; missesValue.textContent = settings.maxMisses; hapticsToggle.checked = settings.haptics; updateHUD(); }
    function fmtName(n){ return n? (n[0].toUpperCase()+n.slice(1).toLowerCase()) : "Player"; }
    function getRecord(name){ return JSON.parse(localStorage.getItem("balloon_"+name) || '{"best":0,"date":"","level":1}'); }
    function setRecord(name, rec){ localStorage.setItem("balloon_"+name, JSON.stringify(rec)); }
    function updateHUD(){ scoreTxt.textContent = `üéØ Score: ${score}`; bestTxt.textContent  = `üèÜ Best: ${bestScore}`; missTxt.textContent  = `‚ùå Missed: ${missed}/${MAX_MISSES}`; whoTxt.textContent   = `üë§ Player: ${playerName||"‚Äî"}`; }
    async function ensurePlayer(){ if(playerName) return; let name = await promptCompat("Please enter your name to play:"); playerName = fmtName(name || "Player"); bestScore = getRecord(playerName).best || 0; updateHUD(); }
    
    async function startGame(){
      initAudio(); await ensurePlayer(); if(isPlaying) return;
      score=0; missed=0; currentLevel=1; balloons.length=0; particles.length=0; isPlaying=true;
      clearTimeout(shieldTimeout); clearInterval(shieldInterval); isShieldActive = false; shieldTimerEl.style.display = 'none';
      isSlowMo = false; clearTimeout(slowMoTimeout);
      // NEW FEATURE: Reset boss state
      isBossLevel = false; bossBalloon = null;
      startBtn.style.display="none"; againBtn.style.display="none"; stopBtn.style.display="grid";
      startSpawning();
      gameTimer  = setInterval(loop, 16);
      startBG(); updateHUD();
    }

    function endGame(msg="Game Over!"){
      clearInterval(spawnTimer); clearInterval(gameTimer); isPlaying=false;
      stopBtn.style.display="none"; startBtn.style.display="grid"; againBtn.style.display="grid"; stopBG();
      if(score > bestScore){ bestScore = score; setRecord(playerName, { best:bestScore, date:new Date().toLocaleDateString(), level: currentLevel }); gameOverTitle.textContent = `üéâ New High Score!`; gameOverMsg.textContent = `${playerName}, you scored ${score}!`; shareBtn.style.display = 'inline-block'; playSound('new_highscore'); } 
      else { gameOverTitle.textContent = `Game Over!`; gameOverMsg.textContent = `${playerName}, your final score was ${score}.`; shareBtn.style.display = 'none'; }
      gameOverPopup.style.display = 'grid'; updateHUD();
    }

    // NEW FEATURE: Moved spawner to its own function to allow restarting after a boss fight
    function startSpawning() {
        if (spawnTimer) clearInterval(spawnTimer);
        let spawnRate = { 'very-easy': 1500, 'easy': 1200, 'medium': 900, 'hard': 650, 'insane': 350 }[settings.difficulty] || 900;
        spawnTimer = setInterval(spawnBalloon, spawnRate);
    }

    function createParticles(x, y, color) { for (let i = 0; i < 15; i++) { particles.push({ x, y, vx: (Math.random() - 0.5) * 5, vy: (Math.random() - 0.5) * 5, radius: Math.random() * 3 + 1, color: color, alpha: 1 }); } }
    function showLevelUpMessage() {
        levelUpMsgEl.textContent = `Level ${currentLevel}!`; levelUpMsgEl.classList.add('show'); playSound('powerup');
        setTimeout(() => { levelUpMsgEl.classList.remove('show'); }, 1500);
    }
    
    // NEW FEATURE: Function to spawn the boss
    function spawnBossBalloon() {
        isBossLevel = true;
        clearInterval(spawnTimer); // Stop normal spawns
        balloons.length = 0; // Clear screen
        const health = 5 + currentLevel;
        bossBalloon = { x: canvas.clientWidth / 2, y: canvas.clientHeight + 100, r: 80, health, maxHealth: health, color: '#4B0082', vy: 0.5 };
        levelUpMsgEl.textContent = "BOSS FIGHT!"; levelUpMsgEl.classList.add('show');
        setTimeout(() => { levelUpMsgEl.classList.remove('show'); }, 2000);
    }

    function spawnBalloon(){
      const x = Math.random() * (canvas.clientWidth - 60) + 30; let type="normal", points=1, color="red", text="", face = null; const r = Math.random();
      // NEW FEATURE: Added Bomb and Swerving balloons with adjusted probabilities
      if      (r < 0.02) { type="rainbow"; points=10; color="white"; text="‚ú®"; }
      else if (r < 0.04) { type="bomb"; points=0; color="#333"; text="üí£"; }
      else if (r < 0.07) { type="heart"; points=1; color="#ff4757"; text="‚ù§Ô∏è"; }
      else if (r < 0.10) { type="shield"; points=2; color="#74b9ff"; text="üõ°Ô∏è"; }
      else if (r < 0.14) { type="freeze"; points=2; color="#add8e6"; text="‚ùÑÔ∏è"; }
      else if (r < 0.18) { type="slowmo"; points=2; color="#ffA500"; text="üïí"; }
      else if (r < 0.22) { type="swerving"; points=3; color="#8A2BE2"; text="üêç"; }
      else if (r < 0.30){ type="gold"; points=5; color="gold"; text="üí∞"; }
      else if (r < 0.40){ type="black"; points=-3; color="black"; text="üíÄ"; }
      else { const colors=["red","yellow","green","blue","deeppink","purple"]; color = colors[Math.floor(Math.random()*colors.length)]; face = faces[Math.floor(Math.random()*faces.length)]; }
      const balloonData = {x, y: canvas.clientHeight+40, r: 28, type, color, points, text, face};
      if(type === 'swerving') { balloonData.originX = x; balloonData.angle = Math.random() * Math.PI * 2; }
      balloons.push(balloonData);
    }

    function drawBalloon(b){ const y=b.y, x=b.x, r=b.r; const grad=ctx.createRadialGradient(x-r*0.3,y-r*0.6,2,x,y,r); grad.addColorStop(0,"#fff"); grad.addColorStop(1,b.color); ctx.beginPath(); ctx.ellipse(x,y,r*0.8,r,0,0,Math.PI*2); ctx.fillStyle=grad; ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.moveTo(x-5,y+r); ctx.lineTo(x+5,y+r); ctx.lineTo(x,y+r+6); ctx.fillStyle="#222"; ctx.fill(); ctx.closePath(); ctx.beginPath(); ctx.moveTo(x,y+r+6); ctx.lineTo(x,y+r+24); ctx.strokeStyle="#222"; ctx.stroke(); ctx.closePath(); if(b.text){ctx.font="bold 20px "+getComputedStyle(document.body).fontFamily; ctx.fillStyle=b.type==='black'?'white':'black'; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(b.text, x, y);} if(b.face){ctx.fillStyle='#000'; ctx.strokeStyle='#000'; ctx.lineWidth=1.5; const eyeY=y-r*0.2, eyeOffsetX=r*0.25; if(b.face.eyes==='normal'||b.face.eyes==='happy'){ctx.beginPath();ctx.arc(x-eyeOffsetX,eyeY,2,0,Math.PI*2);ctx.fill(); ctx.beginPath();ctx.arc(x+eyeOffsetX,eyeY,2,0,Math.PI*2);ctx.fill();}else if(b.face.eyes==='wink'){ctx.beginPath();ctx.arc(x-eyeOffsetX,eyeY,2,0,Math.PI*2);ctx.fill(); ctx.beginPath();ctx.moveTo(x+eyeOffsetX-3,eyeY-2);ctx.lineTo(x+eyeOffsetX+3,eyeY+2);ctx.stroke(); ctx.moveTo(x+eyeOffsetX+3,eyeY-2);ctx.lineTo(x+eyeOffsetX-3,eyeY+2);ctx.stroke();}else if(b.face.eyes==='surprised'){ctx.beginPath();ctx.arc(x-eyeOffsetX,eyeY,3,0,Math.PI*2);ctx.fill(); ctx.beginPath();ctx.arc(x+eyeOffsetX,eyeY,3,0,Math.PI*2);ctx.fill();}if(b.face.eyes==='happy'){ctx.beginPath();ctx.arc(x-eyeOffsetX,eyeY-4,4,Math.PI,Math.PI*2,!0);ctx.stroke(); ctx.beginPath();ctx.arc(x+eyeOffsetX,eyeY-4,4,Math.PI,Math.PI*2,!0);ctx.stroke();} const mouthY=y+r*0.25; ctx.beginPath(); if(b.face.mouth==='smile'){ctx.arc(x,mouthY,r*0.3,0,Math.PI);}else if(b.face.mouth==='open'){ctx.arc(x,mouthY+2,r*0.25,0,Math.PI*2);}else if(b.face.mouth==='big_smile'){ctx.arc(x,mouthY-3,r*0.4,0,Math.PI); ctx.fill();} ctx.stroke();} }
    
    // NEW FEATURE: Function to draw the boss and its health bar
    function drawBossBalloon(b) {
        drawBalloon(b);
        const barWidth = b.r * 1.5, barHeight = 15, barX = b.x - barWidth / 2, barY = b.y - b.r - barHeight - 10;
        ctx.fillStyle = '#555'; ctx.fillRect(barX, barY, barWidth, barHeight);
        const healthWidth = (b.health / b.maxHealth) * barWidth;
        ctx.fillStyle = 'red'; ctx.fillRect(barX, barY, healthWidth, barHeight);
        ctx.font = "bold 14px " + getComputedStyle(document.body).fontFamily;
        ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(`${b.health} / ${b.maxHealth}`, b.x, barY + barHeight / 2);
    }
    
    function loop(){
      ctx.clearRect(0,0,canvas.clientWidth,canvas.clientHeight);
      let baseSpeed = { 'very-slow': 2, 'slow': 3, 'normal': 4, 'fast': 5, 'very-fast': 7 }[settings.speed] || 3;
      if (isSlowMo) { baseSpeed *= 0.5; }

      for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.x += p.vx; p.y += p.vy; p.alpha -= 0.02; if (p.alpha <= 0) { particles.splice(i, 1); } else { ctx.save(); ctx.globalAlpha = p.alpha; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fillStyle = p.color; ctx.fill(); ctx.restore(); } }
      
      // NEW FEATURE: Boss Level Logic
      if (isBossLevel && bossBalloon) {
          bossBalloon.y -= bossBalloon.vy;
          drawBossBalloon(bossBalloon);
          if (bossBalloon.y + bossBalloon.r < 0) {
              endGame("Boss escaped!");
          }
      } else { // Normal game loop
          for(let i=balloons.length-1;i>=0;i--){
            const b = balloons[i];
            // NEW FEATURE: Update swerving balloon position
            if (b.type === 'swerving') {
                b.angle += 0.05;
                b.x = b.originX + Math.sin(b.angle) * (canvas.clientWidth / 8);
            }
            b.y -= baseSpeed + (currentLevel * 0.25); 
            drawBalloon(b);
            if(b.y + b.r < 0){ if(b.type !== "black") { missed++; updateHUD(); if(missed >= MAX_MISSES){ endGame(); } } balloons.splice(i,1); }
          }
      }
    }

    function nativeVibrate(ms) { if (settings.haptics && navigator.vibrate) { navigator.vibrate(ms); } }

    canvas.addEventListener("pointerdown", (e)=>{
      if(!isPlaying) return; const rect = canvas.getBoundingClientRect(); const x = e.clientX - rect.left, y = e.clientY - rect.top;
      
      // NEW FEATURE: Handle boss hits first
      if (isBossLevel && bossBalloon) {
          if (Math.hypot(x - bossBalloon.x, y - bossBalloon.y) < bossBalloon.r * 1.2) {
              nativeVibrate(100);
              bossBalloon.health--;
              createParticles(x, y, 'red');
              playSound('boss_hit');
              if (bossBalloon.health <= 0) {
                  score += 20; // Defeat bonus
                  createParticles(bossBalloon.x, bossBalloon.y, bossBalloon.color);
                  playSound('explosion');
                  isBossLevel = false;
                  bossBalloon = null;
                  // Level up and resume normal play
                  currentLevel++;
                  showLevelUpMessage();
                  startSpawning();
                  updateHUD();
              }
          }
          return; // Don't process normal balloons during boss fight
      }

      for(let i=balloons.length-1;i>=0;i--){
        const b = balloons[i];
        if(Math.hypot(x - b.x, y - b.y) < b.r * 1.2){
          nativeVibrate(50); createParticles(b.x, b.y, b.color === 'white' ? 'gold' : b.color);
          
          if (b.type === 'black' && isShieldActive) { score += 1; playSound('pop'); balloons.splice(i,1); }
          else {
            score += b.points; if(score<0) score=0;
            switch(b.type) {
                case 'rainbow': balloons.forEach(otherB=>{if(otherB!==b)createParticles(otherB.x,otherB.y,otherB.color)}); balloons.length = 0; playSound('powerup'); break;
                case 'heart': if (missed > 0) missed--; playSound('powerup'); break;
                case 'shield': isShieldActive = true; shieldTimerEl.style.display = 'inline-block'; clearTimeout(shieldTimeout); clearInterval(shieldInterval); let shieldEnds = Date.now() + 10000; shieldTimeout = setTimeout(() => { isShieldActive = false; clearInterval(shieldInterval); shieldTimerEl.style.display = 'none'; }, 10000); shieldInterval = setInterval(()=>{ const timeLeft=Math.ceil((shieldEnds-Date.now())/1000); shieldTimerEl.textContent = `üõ°Ô∏è ${timeLeft}s`; }, 500); playSound('powerup'); break;
                case 'freeze': balloons.length = 0; playSound('powerup'); break;
                case 'slowmo': isSlowMo = true; clearTimeout(slowMoTimeout); slowMoTimeout = setTimeout(() => { isSlowMo = false; }, 5000); playSound('powerup'); break;
                // NEW FEATURE: Bomb balloon logic
                case 'bomb':
                    playSound('explosion');
                    const blastRadius = 150;
                    balloons = balloons.filter(otherB => {
                        if (otherB === b) return false;
                        const distance = Math.hypot(b.x - otherB.x, b.y - otherB.y);
                        if (distance < blastRadius) { createParticles(otherB.x, otherB.y, otherB.color); return false; }
                        return true;
                    });
                    i = balloons.length;
                    break;
                case 'black': playSound('fail'); break;
                default: playSound(b.type === "gold" ? 'bling' : 'pop'); break;
            }
            if(b.type !== 'rainbow' && b.type !== 'bomb') balloons.splice(i,1);
          }
          // NEW FEATURE: Boss trigger check after score update
          if (!isBossLevel && score >= currentLevel * 50) {
              spawnBossBalloon();
          }
          updateHUD(); break;
        }
      }
    });
    
    // Original UI, Event Listeners, and Initialization functions
    function showLeaders(){ const players=[]; for(let i=0;i<localStorage.length;i++){ const k=localStorage.key(i); if(k?.startsWith("balloon_")&&!["balloon_settings","balloon_leaderboard"].includes(k)){ const name=k.replace("balloon_",""); const rec=JSON.parse(localStorage.getItem(k)||"{}"); players.push({name, score:rec.best||0, date:rec.date||"-", level: rec.level || 1}); } } players.sort((a,b)=>b.score-a.score); leaderBody.innerHTML=players.slice(0,5).map(p=>`<tr><td>${p.name}</td><td>${p.score}</td><td>${p.level}</td><td>${p.date}</td></tr>`).join("") ||`<tr><td colspan="4" style="text-align:center;">No players yet</td></tr>`; leaderPopup.style.display="grid"; }
    function copyToClipboard(text){ const textArea=document.createElement('textarea'); textArea.value=text; textArea.style.position='fixed'; textArea.style.left='-9999px'; document.body.appendChild(textArea); textArea.focus(); textArea.select(); try{ document.execCommand('copy'); alert('Score message copied to clipboard!');} catch(err){ alert('Could not copy score to clipboard.'); console.error('Fallback copy to clipboard failed:',err); } document.body.removeChild(textArea); }
    shareBtn.addEventListener('click', async () => { const shareData={title:'Balloon Blast Party!',text:`I just scored ${bestScore} in Balloon Blast Party! Can you beat it?`,url:window.location.href}; if(navigator.share && navigator.canShare(shareData)){ try { await navigator.share(shareData); } catch(err) { if(err.name !== 'AbortError') { console.error('Share failed:', err); copyToClipboard(shareData.text+' '+shareData.url); } } } else { console.log('Web Share API not supported or can\'t share, falling back to clipboard.'); copyToClipboard(shareData.text+' '+shareData.url); } });
    
    bindTap(startBtn, startGame); bindTap(stopBtn, ()=> endGame("Game Stopped!")); bindTap(againBtn, startGame);
    bindTap(muteBtn, ()=> { initAudio(); isMuted = !isMuted; muteBtn.textContent = isMuted ? "üîá" : "üîä"; if(isMuted) stopBG(); else if(isPlaying) startBG(); });
    bindTap(switchBtn, async ()=>{if(isPlaying)endGame("Switching Player...");let n=await promptCompat("Enter new player's name:"); playerName=fmtName(n||"Player");bestScore=getRecord(playerName).best||0;score=0;missed=0;updateHUD();});
    bindTap(leadersBtn, showLeaders); bindTap(helpBtnTop, ()=>alert("Pop balloons to score points and avoid black ones! Use power-ups to get ahead. Have fun!üéà\n\n Contact: Amit Dixit"));
    
    // NEW FEATURE: Robust function to handle static and animated themes
    function applyTheme(theme) {
        sunEl.style.display = 'none';
        canvas.style.animation = '';
        canvas.style.backgroundSize = '';
        if (typeof theme === 'string') {
            canvas.style.background = theme;
        } else if (theme && typeof theme === 'object') {
            canvas.style.background = theme.style || '';
            canvas.style.animation = theme.animation || '';
            canvas.style.backgroundSize = theme.backgroundSize || '';
            if (theme.sun) { sunEl.style.display = 'block'; }
        }
    }
    bindTap(paletteBtn, ()=>{currentTheme=(currentTheme+1)%themes.length; applyTheme(themes[currentTheme]);});
    
    bindTap(settingsBtn,()=>settingsPopup.style.display='grid'); bindTap(closeSettings,()=>settingsPopup.style.display='none');
    bindTap(closeLeaders,()=>leaderPopup.style.display='none'); bindTap(closeGameOver,()=>gameOverPopup.style.display='none');
    speedSelect.addEventListener('change',(e)=>{settings.speed=e.target.value;saveSettings();}); difficultySelect.addEventListener('change',(e)=>{settings.difficulty=e.target.value;saveSettings();});
    missesRange.addEventListener('input',(e)=>{settings.maxMisses=parseInt(e.target.value,10);MAX_MISSES=settings.maxMisses;missesValue.textContent=MAX_MISSES;updateHUD();saveSettings();});
    hapticsToggle.addEventListener('change',(e)=>{settings.haptics=e.target.checked;saveSettings();});

    loadSettings();
    applyTheme(themes[currentTheme]); // Use the new function on load
    updateHUD();
});
</script>
</body>
</html>
